/**
 * SOUL.md Auto-Generator
 * Generate a SOUL.md personality profile from extracted traits
 */

import { writeFileSync, existsSync, mkdirSync } from 'fs';
import { dirname, join } from 'path';

export function generateSoulMd(personality, fingerprint, userInfo = {}) {
    const name = userInfo.name || 'User';
    const contacts = userInfo.contacts || {};

    let content = `# SOUL.md — Generated by OpenSelf

## Identity
- Name: ${name}
- Language: ${personality.primaryLanguage || 'Unknown'}
- Total messages analyzed: ${personality.totalMessages}

## Communication Patterns
- Average message length: ${personality.avgMessageLength} chars (~${personality.avgWordCount} words)
- Emoji frequency: ${personality.emojiFrequency > 0.3 ? 'High' : personality.emojiFrequency > 0.1 ? 'Medium' : 'Low'} (${Math.round(personality.emojiFrequency * 100)}% of messages)
- Formality: ${personality.formality}
- Humor: ${personality.humorPatterns.join(', ')}
- Greeting style: ${personality.greetingStyle}
- Average reply time: ${formatTime(personality.responseTimeAvg)}
`;

    // Top emojis
    if (personality.topEmojis && personality.topEmojis.length > 0) {
        content += `- Top emojis: ${personality.topEmojis.slice(0, 5).map(e => e.emoji).join(' ')}\n`;
    }

    // Vocabulary Fingerprint
    content += `
## Vocabulary Fingerprint
`;

    if (personality.catchphrases.length > 0) {
        content += `- Catchphrases: "${personality.catchphrases.slice(0, 10).join('", "')}"\n`;
    }

    const topWordsStr = personality.topWords.slice(0, 15).map(w => w.word).join(', ');
    if (topWordsStr) {
        content += `- Top words: ${topWordsStr}\n`;
    }

    content += `- Never says: "I appreciate your patience", "As an AI...", "I understand your concern"\n`;
    content += `- Capitalization: ${fingerprint.capitalizationStyle}\n`;

    // Vietnamese-specific
    if (personality.primaryLanguage === 'Vietnamese' || personality.pronounUsage.length > 0) {
        content += `
## Vietnamese Style
`;
        if (personality.pronounUsage.length > 0) {
            content += `- Pronoun usage: ${personality.pronounUsage.join(', ')}\n`;
        }
        content += `- Diacritics: ${personality.toneDiacritics ? 'Full diacritics used' : 'Sometimes skipped'}\n`;

        if (personality.abbreviations.length > 0) {
            content += `- Abbreviations: ${personality.abbreviations.join(', ')}\n`;
        }

        if (personality.usesSlang) {
            content += `- Slang: Frequently used\n`;
        }
    }

    // Boundaries (sensible defaults)
    content += `
## Boundaries
- Never share: Personal finances, health info, passwords, private addresses
- Deflect topics: Deep politics, religion (say "ko bàn mấy cái này")
- When unsure: Say "${personality.primaryLanguage === 'Vietnamese' ? 'để t hỏi lại' : "let me check on that"}" (don't make up answers)
- Sensitive mode: If someone seems upset, switch to caring tone
`;

    // Relationships
    if (Object.keys(contacts).length > 0) {
        content += `
## Relationships
`;
        for (const [contactName, info] of Object.entries(contacts)) {
            content += `- @${contactName}: ${info.relationship || 'Friend'} (${info.messageCount || 0} messages)\n`;
        }
    }

    // Clone behavior defaults
    content += `
## Clone Behavior
- proactive_messages: false
- reply_delay: random 30s-5min
- typing_indicator: true
- read_receipt_delay: random 10s-2min
- online_hours: 08:00-23:00
- fallback: "${personality.primaryLanguage === 'Vietnamese' ? 'Để t check lại rồi rep sau nha' : 'Let me get back to you on that'}"
`;

    return content.trim();
}

/**
 * Save SOUL.md to data directory
 */
export function saveSoulMd(content, dataDir = './data') {
    if (!existsSync(dataDir)) {
        mkdirSync(dataDir, { recursive: true });
    }
    const filePath = join(dataDir, 'SOUL.md');
    writeFileSync(filePath, content, 'utf-8');
    return filePath;
}

function formatTime(ms) {
    if (ms < 0) return 'instant';
    if (ms < 60000) return `${Math.round(ms / 1000)}s`;
    if (ms < 3600000) return `${Math.round(ms / 60000)}min`;
    return `${Math.round(ms / 3600000)}h`;
}
